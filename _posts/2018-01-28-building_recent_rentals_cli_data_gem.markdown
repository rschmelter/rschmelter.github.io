---
layout: post
title:      "Building Recent Rentals CLI Data Gem"
date:       2018-01-28 17:13:57 +0000
permalink:  building_recent_rentals_cli_data_gem
---


My biggest concern when starting the CLI Data Gem project was getting started and actually setting up the gem. On top of methods, objects and everything else that goes into building an application, there’s also a lot to learn about organizing a file structure, GitHub, publishing, and, what can sometimes seem like an endless number of other details required to actually make an application work. It can be anxiety-inducing to stare at a blinking cursor and not be sure where to begin, which, for me, involved hours of googling, reading, realizing I was reading something that didn’t quite apply, googling again, reading again, and watching videos. This process does, however, make it more satisfying when everything is up and running.

Once I got my gem file structure set up using bundle install and set up my repo on GitHub, I was confident that it would be relatively smooth sailing, which wasn’t really the case. I made one good decision and one mistake early on. I chose to scrape Craigslist for the most recently listed rentals in cities from all 50 states, Washington D.C., and US territories, which proved challenging for other reasons. The good decision was to create a detailed plan of how I wanted the application to work. This helped me work out objects and logic with relative ease. The mistake was choosing to first work out scraping the data before doing anything else.

I created a plan for how to store the scraped data and assumed that using it to instantiate objects would be easy as long as it was captured in a logical way. But, when the time came to actually create objects from the scraped data, I realized that, more often than not, it would have been better to have stored the data in a different way. For example, I stored state, city text, and city URL data as a hash like this: {State = > [city, city, city, etc], [city url, city url, city url, etc]. It wasn’t long after creating the City class, that I realized it would have been much easier to associate the city and its url in some way, which required that I revisit the Scraper code and make adjustments. I’ve heard the phrase “write the code you wish you had” used repeatedly in the Flatiron curriculum, and it makes more sense to me now. I would have had an easier time setting up my objects to determine what data they would need to be instantiated with before scraping. 

Fortunately, the curriculum has given me a solid understanding of how objects interact, and I felt reasonably confident writing the classes code. I chose to make everything that was presented to the user into an object, so each state, city, rental type, and rental, was an object instantiated in their own classes. One of the biggest obstacles I encountered when setting up these classes was in maintaining a relationship between all of them. A state has many cities. A city has many rental types. A rental type has many rentals. I wanted to, for example, have a State have many rentals through its cities’ rental types. This required having a “has many through” relationship with states, cities, and rental types, and then using that method to get rentals by iterating through a State’s rental types. This, in turn, required cities to have many rentals through rental types. And, of course, each class needed “has many” and “belongs to” methods. I didn’t use all of these methods in the application. However, it seemed like having them would provide more flexibility if, for example, I wanted to expand the code and allow a user to get all the rentals in all cities in a state. 

I encountered another set of challenges in building the CLI. I wanted to give the user the option to either list out the states available or to type in the name of a state. This required a find_by_name method in the State class, and I found it challenging to ensure the user’s input would match the names of the state objects.

Additionally, the options the user has to select from in this application are simple, however, I wanted to make sure I wasn’t simply basing my code off what was being presented to the user, as this would make it inflexible. For example, I knew the user would almost always be presented with 120 rental options to choose from. However, if this changed for any reason, something could easily break. This taught me to use the relationships between my classes. Instead of setting up a condition to see if the user’s input was between 1 and 120, I could determine the length of the rentals array in the type object and test if the user’s input was between 1 and that number. There’s a lot to anticipate, and I can see how dealing with all the potential edge cases can get very difficult in more complex applications.

I think the most satisfying part of building this project was the confidence I gained in looking up answers I needed. I started to get a feel for when there was likely some method to handle a problem I encountered. And, when there wasn’t such a method, finding some way to work around the problem. I also found it fun to refactor my code and find more efficient ways to get the same result – although I’m sure there’s still plenty of ways that haven’t occurred to me yet. 

